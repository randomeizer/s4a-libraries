// Author: David Peterson
// Date: 28/11/2020
// IDE Version: 4.5
// Description: This library provides support for the MPU-6050 (and MPU-6000) modules, which provide gyro/accelerometer/temp measurements.

import AVR

// Reference code:
// * https://courses.cs.washington.edu/courses/cse466/14au/labs/l4/MPU6050BasicExample.ino

/// Represents an MPU6050 connection.
public struct MPU6050: I2CSlaveNode {

    /// Indicates which unit this is, if more than one MPU6050 is configured.
    public let address: Address

    /// Constructs an `MPU-6050` unit.
    ///
    /// Note: The actual device is not not fully configured after executing this.
    ///
    /// - Parameter address: The specific slave address of this unit.
    public init(address: Address = .zero) {
        self.address = address
    }

    /// Specify which MPU6050 unit this is, if there is more than one.
    /// The actual unit of the module is defined by the logic state of the `AD0` (pin 9).
    public enum Address: UInt8, I2CSlaveAddress {
        /// Address when `AD0` pin is set to `0`.
        case zero = 0b110_100_0

        /// Address when `AD0` pin is set to `1`.
        case one  = 0b110_100_1
    }
}

// basic functions
extension MPU6050 {

    /// Indicates the unit should start processing data with some default values.
    mutating func begin(
        sampleRateDivider: UInt8 = 0,
        config: Config = Config(registerValue: 0),
        gyroFullScaleRange: GyroConfig.FullScaleRange = .fsr1000DPS,
        accelFullScaleRange: AccelConfig.FullScaleRange = .fsr2g,
        powerManagementClock: PowerManagement.ClockSource = .xAxisGyro
    ) {
        self.sampleRateDivider = sampleRateDivider
        self.config = config
        self.gyroConfig.fullScaleRange = gyroFullScaleRange
        self.accelConfig.fullScaleRange = accelFullScaleRange
        self.powerManagement.clock = powerManagementClock

    /*
        this->update();
        angleGyroX = 0;
        angleGyroY = 0;
        angleX = this->getAccAngleX();
        angleY = this->getAccAngleY();
        preInterval = millis();
    */
    }
}

// Sample Rate and other configuration.

extension MPU6050 {
    /// The accelerometer output rate in kHz.
    public static let accelerometerOutputRate: UInt8 = 1 // kHz

    /// This register specifies the divider from the gyroscope output rate
    /// used to generate the Sample Rate for the MPU-60X0.
    public var sampleRateDivider: UInt8 {
        get { read(from: 0x19) }
        set { write(to: 0x19, value: newValue) }
    }

    /// The current sample rate.
    ///
    /// The sensor register output, FIFO output, and DMP sampling are all based on the Sample Rate.
    ///
    /// The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:
    ///
    ///     Sample Rate = Gyroscope Output Rate / (1 + `sampleRateDivider`)
    ///
    /// where Gyroscope Output Rate = 8kHz when the DLPF is disabled (`ditigalLowPassFilter` = `.zero` or `.seven`), and 1kHz when the DLPF is enabled (see Register 26).
    ///
    /// Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.
    public var sampleRate: Float {
        Float(gyroscopeOutputRate) / (1.0 + Float(sampleRateDivider))
    }

    /// This register configures the external Frame Synchronization (`FSYNC`)
    /// pin sampling and the Digital Low Pass Filter (DLPF) setting
    /// for both the gyroscopes and accelerometers.
    public var config: Config {
        get { read(from: Config.address) }
        set { write(to: Config.address, value: newValue) }
    }

    /// Gyroscope Output Rate = 8kHz when the DLPF is disabled
    /// (`config.digitalLowPassFilter` = `.zero` or `.seven`),
    /// and 1kHz when the DLPF is enabled.
    public var gyroscopeOutputRate: UInt8 {
        config.digitalLowPassFilter.gyroFrameSync
    }

    /// Describes the `CONFIG` register (`0x1A`) contents.
    public struct Config: I2CMutableRegisterData {
        /// The register address
        public static let address: UInt8 = 0x1A

        /// The raw register value.
        public var registerValue: UInt8

        public init(registerValue: UInt8) {
            self.registerValue = registerValue
        }

        /// An external signal connected to the `FSYNC` pin can be sampled by configuring `externalSyncSetting`.
        ///
        /// Signal changes to the `FSYNC` pin are latched so that short strobes
        /// may be captured. The latched `FSYNC` signal will be sampled at
        /// the Sampling Rate, as defined in register 25.
        /// After sampling, the latch will reset to the current `FSYNC` signal state.
        ///
        /// The sampled value will be reported in place of the least significant
        /// bit in a sensor data register determined by the value here.
        public var externalSyncSetting: ExternalSyncSetting {
            get { getBits(from: 3...5) }
            set { setBits(from: 3...5, to: newValue) }
        }

        /// Configures the Digital Low Pass Filter for the accelerometer and gyro.
        public var digitalLowPassFilter: DigitalLowPassFilter {
            get { getBits(from: 0...2) }
            set { setBits(from: 0...2, to: newValue) }
        }

        /// Indicates where the `FSYNC` bit will get stored.
        public enum ExternalSyncSetting: UInt8 {
            case disabled      = 0
            case tempOutLow    = 1
            case gyroXOutLow   = 2
            case gyroYOutLow   = 3
            case gyroZOutLow   = 4
            case accelXOutLow  = 5
            case accelYOutLow  = 6
            case accelZOutLow  = 7
        }

        /// Configures the Digital Low-Pass Filter. Each setting has different
        /// settings for accelerometer and gyro bandwidth/delay/frame sync frequency.
        public enum DigitalLowPassFilter: UInt8 {
            case zero          = 0
            case one           = 1
            case two           = 2
            case three         = 3
            case four          = 4
            case five          = 5
            case six           = 6
            case seven         = 7

            /// Accelerometer Bandwidth (Hz)
            public var accelBandwidth: UInt16? {
                switch self {
                case .zero:    return 260
                case .one:     return 184
                case .two:     return 94
                case .three:   return 44
                case .four:    return 21
                case .five:    return 10
                case .six:     return 5
                case .seven:   return nil
                }
            }

            /// Accelerometer Delay (ms)
            public var accelDelay: Float? {
                switch self {
                case .zero:    return 0.0
                case .one:     return 2.0
                case .two:     return 3.0
                case .three:   return 4.9
                case .four:    return 8.5
                case .five:    return 13.8
                case .six:     return 19.0
                case .seven:   return nil
                }
            }

            /// Gyroscope Bandwidth (Hz)
            public var gyroBandwidth: UInt16? {
                switch self {
                case .zero:    return 256
                case .one:     return 188
                case .two:     return 98
                case .three:   return 42
                case .four:    return 20
                case .five:    return 10
                case .six:     return 5
                case .seven:   return nil
                }
            }

            /// Gyroscope Delay (ms)
            public var gyroDelay: Float? {
                switch self {
                case .zero:    return 0.98
                case .one:     return 1.9
                case .two:     return 2.8
                case .three:   return 4.8
                case .four:    return 8.3
                case .five:    return 13.4
                case .six:     return 18.6
                case .seven:   return nil
                }
            }

            /// Gyroscope Frame Sync (kHz)
            public var gyroFrameSync: UInt8 {
                switch self {
                case .zero, .seven:
                    return 8
                case .one, .two, .three, .four, .five, .six:
                    return 1
                }
            }
        }
    }
}

extension MPU6050 {
    /// Configures the gyroscope.
    public var gyroConfig: GyroConfig {
        get { read(from: 0x1B) }
        set { write(to: 0x1B, value: newValue) }
    }

    // Configures the accelerometer.
    public var accelConfig: AccelConfig {
        get { read(from: 0x1C) }
        set { write(to: 0x1C, value: newValue) }
    }
}

public struct GyroConfig: I2CMutableRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// Each 16-bit gyroscope measurement has a full scale defined in here. For each full scale setting,
    /// the gyroscopes’ sensitivity per LSB in `gyroOut` is shown in the table below:
    ///
    /// || `FullScaleRange` ||    Value    ||
    /// |     .fsr250DPS    |   ± 250 ˚/s  ||
    /// |     .fsr500DPS    |   ± 500 ˚/s  ||
    /// |    .fsr1000DPS    |  ± 1000 ˚/s  ||
    /// |    .fsr2000DPS    |  ± 2000 ˚/s  ||
    var fullScaleRange: FullScaleRange {
        get { getBits(from: 3...4) }
        set { setBits(from: 3...4, to: newValue) }
    }

    /// The options for the full scale range of the gyro.
    public enum FullScaleRange: UInt8 {
        /// ± 250 °/s
        case fsr250DPS = 0

        /// ± 500 °/s
        case fsr500DPS = 1

        /// ± 1000 °/s
        case fsr1000DPS = 2

        /// ± 2000 °/s
        case fsr2000DPS = 3

        public var degreesPerSecond: UInt16 {
            switch self {
                case .fsr250DPS: return 250
                case .fsr500DPS: return 500
                case .fsr1000DPS: return 1_000
                case .fsr2000DPS: return 2_000
            }
        }
    }
}

public struct AccelConfig: I2CMutableRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// Selects the full scale range of the accelerometer outputs according to the following table:
    ///
    /// || `FullScaleRange` ||   Value  ||
    /// |     `.fsr2g`      |     ± 2g  ||
    /// |     `.fsr4g`      |     ± 4g  ||
    /// |     `.fsr8g`      |     ± 8g  ||
    /// |    `.fsr16g`      |    ± 16g  ||
    public var fullScaleRange: FullScaleRange {
        get { getBits(from: 3...4) }
        set { setBits(from: 3...4, to: newValue) }
    }

    public enum FullScaleRange: UInt8 {
        case fsr2g = 0
        case fsr4g = 1
        case fsr8g = 2
        case fsr16g = 3

        /// The sensitivity in `g`s.
        var gravity: UInt8 {
            switch self {
                case .fsr2g: return 2
                case .fsr4g: return 4
                case .fsr8g: return 8
                case .fsr16g: return 16
            }
        }
    }

}

//------------------------------------------------------------------------------
// Interrupts
//------------------------------------------------------------------------------

extension MPU6050 {
    public var interruptConfig: InterruptConfig {
        get { read(from: 0x37) }
        set { write(to: 0x37, value: newValue) }
    }

    public var interruptEnable: InterruptEnable {
        get { read(from: 0x38) }
        set { write(to: 0x38, value: newValue) }
    }

    public var interruptStatus: InterruptStatus {
        read(from: 0x3A)
    }
}

/// This register configures the behavior of the interrupt signals at the
/// `INT` pins. This register is also used to enable the `FSYNC` Pin to
/// be used as an interrupt to the host application processor, as well
/// as to enable Bypass Mode on the I2C Master. This bit also enables the
/// clock output.
///
/// `fsyncInterruptEnabled` enables the `FSYNC` pin to be used as an
/// interrupt to the host application processor. A transition to the
/// active level specified in `fsyncInterruptLevel` will trigger an interrupt.
/// The status of this interrupt is read from the `passThrough` bit in
/// the I2C Master Status Register (Register 54).
///
/// When `I2C_BYPASS_EN` is equal to `true` and `I2C_MST_EN`
/// (Register 106 `bit[5]``) is equal to `false`, the host application
/// processor will be able to directly access the auxiliary I2C bus of
/// the MPU-60X0. When this bit is equal to `false`, the host application
/// processor will not be able to directly access the auxiliary I2C bus
/// of the MPU-60X0 regardless of the state of `I2C_MST_EN`.
///
/// For further information regarding Bypass Mode, please refer to
/// Section 7.11 and 7.13 of the MPU6000/MPU-6050 Product Specification
/// document.
public struct InterruptConfig: I2CMutableRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// When this is set to `.activeHigh`, the logic level for the
    /// INT pin is active high. When this is equal to `.activeLow`,
    /// the logic level for the INT pin is active low.
    var interruptLevel: LogicLevel {
        get { getBit(at: 7) }
        set { setBit(at: 7, to: newValue) }
    }

    /// When this is `false`, the `INT` pin is configured as push-pull.
    /// When this is `true`, the `INT` pin is configured as open drain.
    var interruptOpen: Bool {
        get { hasBit(at: 6) }
        set { setBit(at: 6, to: newValue) }
    }

    /// When this is `false`, the `INT` pin emits a 50us long pulse.
    /// When this is `true`, the `INT` pin is held high until the
    /// interrupt is cleared.
    var latchInterruptEnabled: Bool {
        get { hasBit(at: 5) }
        set { setBit(at: 5, to: newValue) }
    }

    /// When this is `false`, interrupt status bits are cleared only by
    /// reading `interruptStatus` (Register 58).
    ///
    /// When this is `true`, interrupt status bits are cleared on any
    /// read operation.
    var interruptReadClear: InterruptClear {
        get { getBit(at: 4) }
        set { setBit(at: 4, to: newValue) }
    }

    /// When this is `.activeHigh`, the logic level for the `FSYNC` pin
    /// (when used as an interrupt to the host processor) is active high.
    ///
    /// When this is `.activeLow`, the logic level for the `FSYNC` pin
    /// (when used as an interrupt to the host processor) is active low.
    var fsyncInterruptLevel: LogicLevel {
        get { getBit(at: 3) }
        set { setBit(at: 3, to: newValue) }
    }

    /// When `true`, this enables the `FSYNC` pin to be used as an interrupt to the host processor.
    var fsyncInterruptEnabled: Bool {
        get { hasBit(at: 2) }
        set { setBit(at: 2, to: newValue) }
    }

    /// When this is `true` and `I2C_MST_EN` (Register 106 bit[5]) is `false`,
    /// the host application processor will be able to directly access the
    /// auxiliary I2C bus of the MPU-60X0.
    ///
    /// When this is `false`, the host application processor will not be able
    /// to directly access the auxiliary I2C bus of the MPU-60X0 regardless
    /// of the state of `I2C_MST_EN` (Register 106 bit[5]).
    var i2cBypassEnabled: Bool {
        get { hasBit(at: 1) }
        set { setBit(at: 1, to: newValue) }
    }

    /// The logic level options
    public enum LogicLevel: UInt8 {
        case activeHigh = 0
        case activeLow = 1
    }

    public enum InterruptClear: UInt8 {
        case byReadingInterruptStatus = 0
        case byAnyReadOperation = 1
    }
}

/// Register 56 - Interrupt Enable
/// This register enables interrupt generation by interrupt sources.
///
///For information regarding the interrupt status for each interrupt generation source,
/// please refer to Register 58. Further information regarding I2 CMaster interrupt
/// generation can be found in Register 54.
///
/// Bits 2 and 1 are reserved.
public struct InterruptEnable: I2CMutableRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// When set to `true`, this bit enables any of the I2C Master interrupt sources to generate an interrupt.
    public var i2CMasterInterruptEnabled: Bool {
        get { hasBit(at: 3) }
        set { setBit(at: 3, to: newValue) }
    }

    /// When set to 1, this bit enables the Data Ready interrupt, which occurs each time a write operation to
    /// all of the sensor registers has been completed.
    public var dataReadyEnabled: Bool {
        get { hasBit(at: 0) }
        set { setBit(at: 0, to: newValue) }
    }
}

/// This register shows the interrupt status of each interrupt generation source. Each bit will clear after
/// the register is read.
///
/// For information regarding the corresponding interrupt enable bits, please refer to Register 56.
///
/// For a list of I2C Master interrupts, please refer to Register 54.
///
/// Bits 2 and 1 are reserved.
public struct InterruptStatus: I2CRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// This bit automatically sets to `true` when an I2C Master interrupt has been generated.
    /// For a list of I2C Master interrupts, please refer to Register 54.
    ///
    /// The bit clears to `false` after the register has been read.
    public var i2CMasterInterrupt: Bool { hasBit(at: 3) }

    /// This bit automatically sets to `true` when a Data Ready interrupt is generated.
    /// The bit clears to `false after the register has been read.
    public var dataReadyInterrupt: Bool { hasBit(at: 0) }
}

//------------------------------------------------------------------------------
// Sensor Measurements
//------------------------------------------------------------------------------

/// These registers store the most recent accelerometer measurements.
///
/// Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25.
///
/// The accelerometer measurement registers, along with the temperature measurement registers, gyroscope
/// measurement registers, and external sensor data registers, are composed of two sets of registers:
/// an internal register set and a user-facing read register set.
///
/// The data within the accelerometer sensors’ internal register set is always updated at the Sample Rate.
/// Meanwhile, the user-facing read register set duplicates the internal register set’s data values
/// whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read
/// measurements from the same sampling instant. Note that if burst reads are not used, the user is
/// responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking
/// the Data Ready interrupt.
///
/// Each 16-bit accelerometer measurement has a full scale defined in `ACCEL_FS` (Register 28). For each
/// full scale setting, the accelerometers’ sensitivity per LSB in `accelOut` is shown in the table below.
///
/// || AFS_SEL || Full Scale Range || LSB Sensitivity ||
/// |     0    |      +/-2g        |    16384 LSB/g    |
/// |     1    |      +/-4g        |     8192 LSB/g    |
/// |     2    |      +/-8g        |     4096 LSB/g    |
/// |     0    |     +/-16g        |     2048 LSB/g    |
public struct AccelOut {
    /// Stores the most recent X axis accelerometer measurement.
    public let x: Int16

    /// Stores the most recent Y axis accelerometer measurement.
    public let y: Int16

    /// Stores the most recent Z axis accelerometer measurement.
    public let z: Int16
}

/// These registers store the most recent gyroscope measurements.
///
/// Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25.
///
/// These gyroscope measurement registers, along with the accelerometer measurement registers, temperature
/// measurement registers, and external sensor data registers, are composed of two sets of registers:
/// an internal register set and a user-facing read register set.
///
/// The data within the gyroscope sensors’ internal register set is always updated at the Sample Rate.
/// Meanwhile, the user-facing read register set duplicates the internal register set’s data values whenever
/// the serial interface is idle. This guarantees that a burst read of sensor registers will read
/// measurements from the same sampling instant. Note that if burst reads are not used, the user is
/// responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking
/// the Data Ready interrupt.
///
/// Each 16-bit gyroscope measurement has a full scale defined in `FS_SEL` (Register 27). For each full scale
/// setting, the gyroscopes’ sensitivity per LSB in `GYRO_xOUT` is shown in the table below:
///
/// || FS_SEL || Full Scale Range || LSB Sensitivity ||
/// |    0    |     +/- 250 ˚/s   |    131 LSB/˚/s   ||
/// |    1    |     +/- 500 ˚/s   |   65.5 LSB/˚/s   ||
/// |    2    |    +/- 1000 ˚/s   |   32.8 LSB/˚/s   ||
/// |    3    |    +/- 2000 ˚/s   |   16.4 LSB/˚/s   ||
public struct GyroOut {
    /// Stores the most recent X axis gyro measurement.
    public let x: Int16

    /// Stores the most recent Y axis gyro measurement.
    public let y: Int16

    /// Stores the most recent Z axis gyro measurement.
    public let z: Int16
}

/// The temperature in degrees C for a given register value may be computed as:
///
///     Temperature in degrees C = (`tempOut` Register Value as a signed quantity)/340 + 36.53
private func tempToCelcius(temp: Int16) -> Float {
    return Float(temp)/340.0 + 36.53
}

/// Combined readings for the accelerometer, gyro, and temperature.
public struct SensorOut {
    public let accel: AccelOut
    public let temp: Int16
    public let gyro: GyroOut

    /// The temperature in degrees celcius.
    ///
    /// The temperature in degrees C for a given register value may be computed as:
    ///
    ///     Temperature in degrees C = (`tempOut` Register Value as a signed quantity)/340 + 36.53
    ///
    /// Please note that the math in the above equation is in decimal.
    public var tempCelcius: Float {
        tempToCelcius(temp: temp)
    }
}

extension MPU6050 {
    /// The most recent X, Y and Z accelerometer measurements.
    public var accelOut: AccelOut {
        get { read(from: 0x3B...0x40) }
    }

    /// These registers store the most recent temperature sensor measurement.
    ///
    /// Temperature measurements are written to these registers at the Sample Rate as defined in Register 25.
    ///
    /// These temperature measurement registers, along with the accelerometer measurement registers, gyroscope
    /// measurement registers, and external sensor data registers, are composed of two sets of registers:
    /// an internal register set and a user-facing read register set.
    ///
    /// The data within the temperature sensor’s internal register set is always updated at the Sample Rate.
    /// Meanwhile, the user-facing read register set duplicates the internal register set’s data values whenever
    /// the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements
    /// from the same sampling instant. Note that if burst reads are not used, the user is responsible for
    /// ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.
    ///
    /// The scale factor and offset for the temperature sensor are found in the Electrical Specifications table
    /// (Section 6.4 of the MPU-6000/MPU-6050 Product Specification document).
    public var tempOut: Int16 {
        read(from: 0x41...0x42)
    }

    /// The temperature in degrees celcius.
    ///
    /// The temperature in degrees C for a given register value may be computed as:
    ///
    ///     Temperature in degrees C = (`tempOut` Register Value as a signed quantity)/340 + 36.53
    ///
    /// Please note that the math in the above equation is in decimal.
    public var tempCelcius: Float {
        tempToCelcius(temp: tempOut)
    }

    /// The most recent X, Y, and Z gyro measurements.
    public var gyroOut: GyroOut {
        get { read(from: 0x43...0x48) }
    }

    /// The combined sensor data for the accelerometer, gyro, and temperature.
    public var sensorOut: SensorOut {
        get { read(from: 0x3B...0x48) }
    }
}

//------------------------------------------------------------------------------
// Configuration
//------------------------------------------------------------------------------

extension MPU6050 {
    /// Register 104: Signal Path Reset
    public var signalPathReset: SignalPathReset {
        get { read(from: 0x68) }
        set { write(to: 0x68, value: newValue) }
    }

    /// Register 106: User Control
    public var userControl: UserControl {
        get { read(from: 0x6A) }
        set { write(to: 0x6A, value: newValue) }
    }

    public var powerManagement: PowerManagement {
        get { read(from: 0x6B...0x6C) }
        set { write(to: 0x6B...0x6C, value: newValue) }
    }
}

/// # Register 104: Signal Path Reset
///
/// This register is used to reset the analog and digital signal paths of the gyroscope,
/// accelerometer, and temperature sensors.
///
/// The reset will revert the signal path analog to digital converters and filters to their
/// power up configurations.
///
/// Note: This register does not clear the sensor registers. The reset initializes the serial interface as well.
///
/// Bits 7 to 3 are reserved.
public struct SignalPathReset: I2CMutableRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// When set to `true`, this bit resets the gyroscope analog and digital signal paths.
    public var gyroReset: Bool {
        get { hasBit(at: 2) }
        set { setBit(at: 2, to: newValue) }
    }

    /// When set to `true`, this bit resets the accelerometer analog and digital signal paths.
    public var accelReset: Bool {
        get { hasBit(at: 1) }
        set { setBit(at: 1, to: newValue) }
    }

    /// When set to `true`, this bit resets the temperature sensor analog and digital signal paths.
    public var tempReset: Bool {
        get { hasBit(at: 0) }
        set { setBit(at: 0, to: newValue) }
    }
}

/// # Register 106: User Control
///
/// This register allows the user to enable and disable the FIFO buffer, I2 C Master Mode, and primary I2 C interface.
/// The FIFO buffer, I2C Master, sensor signal paths and sensor registers can also be reset using this register.
///
/// When `i2CMasterEnabled` is set to `true`, I2C Master Mode is enabled. In this mode, the MPU-60X0 acts as the
/// I2C Master to the external sensor slave devices on the auxiliary I2C bus. When this is set to `false`, the
/// auxiliary I2C bus lines (`AUX_DA` and `AUX_CL`) are logically driven by the primary I2C bus (`SDA` and `SCL`).
/// This is a precondition to enabling Bypass Mode. For further information regarding Bypass Mode, please refer to Register 55.
///
/// Bits 7 and 3 are reserved.
public struct UserControl: I2CMutableRegisterData {
    public var registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// When set to `true`, this bit enables I2C Master Mode.
    ///
    /// When this set to `false`, the auxiliary I2C bus lines (`AUX_DA` and `AUX_CL`) are logically driven by the primary I2C bus (`SDA` and `SCL`).
    public var i2CMasterEnabled: Bool {
        get { hasBit(at: 5) }
        set { setBit(at: 5, to: newValue) }
    }

    /// MPU-6000: When set to `true`, this bit disables the primary I2C interface and enables the SPI interface instead.
    ///
    /// MPU-6050: Always write this bit as zero.
    public var i2CInterfaceDisabled: Bool {
        get { hasBit(at: 4) }
        set { setBit(at: 4, to: newValue) }
    }

    /// This bit resets the I2C Master when set to `true` while `i2CMasterEnabled` equals `false`.
    /// This bit automatically resets to `false` after the reset has been triggered.
    public var i2CMasterReset: Bool {
        get { hasBit(at: 1) }
        set { setBit(at: 1, to: newValue) }
    }

    /// When set to `true`, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor).
    /// This operation will also clear the sensor registers. This bit automatically resets to `false` after the reset has been triggered.
    ///
    /// When resetting only the signal path (and not the sensor registers), please use Register 104, `SignalPathReset`.
    public var signalConditionReset: Bool {
        get { hasBit(at: 0) }
        set { setBit(at: 0, to: newValue) }
    }
}

/// `PowerManagement` combines both Power Management registers (107 and 108). Details follow:
///
/// # Register 107: Power Management 1
///
/// This register allows the user to configure the power mode and clock source. It also provides a bit for resetting the entire device,
/// and a bit for disabling the temperature sensor.
///
/// By setting `sleep` to `true`, the MPU-60X0 can be put into low power sleep mode. When `cycle` is set to `true` while `sleep` is disabled,
/// the MPU-60X0 will be put into Cycle Mode. In Cycle Mode, the device cycles between sleep mode and waking up to take a single sample of
/// data from accelerometer at a rate determined by `lowPowerWakeup` (register 108). To configure the wake frequency,
/// use `lowPowerWakeup` within the Power Management 2 register (Register 108).
///
/// An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source. When the internal
/// 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled.
///
/// Upon power up, the MPU-60X0 clock source defaults to the internal oscillator. However, it is highly recommended that the device be
/// configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability. See `ClockSource` for details
/// on the options for clock configuration.
///
/// For further information regarding the MPU-60X0 clock source, please refer to the `MPU-6000/MPU6050 Product Specification` document.
///
/// Bit 4 is reserved.
///
/// # Register 108: Power Management 2
///
/// This register allows the user to configure the frequency of wake-ups in Accelerometer Only Low Power Mode. This register also allows
/// the user to put individual axes of the accelerometer and gyroscope into standby mode.
///
/// The MPU-60X0 can be put into Accelerometer Only Low Power Mode using the following steps:
///
/// (i) Set `cycle` to `true`
/// (ii) Set `sleep` to `false`
/// (iii) Set `temperatureSensorDisable` to `true`
/// (iv) Set `standbyGyroX`, `standbyGyroY`, `standbyGyroZ` to `false`
///
/// All of the above bits can be found in Power Management 1 register (Register 107).
///
/// In this mode, the device will power off all devices except for the primary I2C interface, waking only the accelerometer at fixed
/// intervals to take a single measurement. The frequency of wake-ups can be configured with `lowPowerWakeup` as shown below.
///
/// || `lowPowerWakeup` || Wake-up Frequency ||
/// |           0            |       1.25 Hz       |
/// |           1            |          5 Hz       |
/// |           2            |         20 Hz       |
/// |           3            |         40 Hz       |
///
/// For further information regarding the MPU-6050’s power modes, please refer to Register 107.
///
/// The user can put individual accelerometer and gyroscopes axes into standby mode by using this register. If the device is using a gyroscope
/// axis as the clock source and this axis is put into standby mode, the clock source will automatically be changed to the internal 8MHz oscillator.

public struct PowerManagement {
    public var register1: UInt8
    public var register2: UInt8

    /// When set to `true`, this resets all internal registers to their default values.
    ///
    /// It automatically resets to `false` once the reset is done.
    ///
    /// The default values for each register can be found in Section 3.
    public var deviceReset: Bool {
        get { register1.hasBit(at: 7) }
        set { register1.setBit(at: 7, to: newValue) }
    }

    /// When set to `true`, this bit puts the MPU-60X0 into sleep mode. The device boots with this set to `true`.
    public var sleep: Bool {
        get { register1.hasBit(at: 6) }
        set { register1.setBit(at: 6, to: newValue) }
    }

    /// When this bit is set to `true` and `sleep` is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a
    /// single sample of data from active sensors at a rate determined by `lowPowerWakeup` (register 108).
    public var cycle: Bool {
        get { register1.hasBit(at: 5) }
        set { register1.setBit(at: 5, to: newValue) }
    }

    /// When set to `true`, this disables the temperature sensor.
    public var temperatureSensorDisabled: Bool {
        get { register1.hasBit(at: 3) }
        set { register1.setBit(at: 3, to: newValue) }
    }

    /// The clock source. Defaults to `.internal`.
    public var clock: ClockSource {
        get { register1.getBits(from: 0...2) }
        set { register1.setBits(from: 0...2, to: newValue) }
    }

    /// The MPU-60X0 has a flexible clocking scheme, allowing a variety of internal or external clock sources to be used for the
    /// internal synchronous circuitry. This synchronous circuitry includes the signal conditioning and ADCs, the DMP, and various
    /// control circuits and registers. An on-chip PLL provides flexibility in the allowable inputs for generating this clock.
    ///
    /// Allowable internal sources for generating the internal clock are:
    ///
    /// - An internal relaxation oscillator
    /// - Any of the X, Y, or Z gyros (MEMS oscillators with a variation of ±1% over temperature)
    ///
    /// Allowable external clocking sources are:
    ///
    /// - 32.768kHz square wave
    /// - 19.2MHz square wave
    ///
    /// Selection of the source for generating the internal synchronous clock depends on the availability of external sources and the
    /// requirements for power consumption and clock accuracy. These requirements will most likely vary by mode of operation.
    /// For example, in one mode, where the biggest concern is power consumption, the user may wish to operate the Digital Motion Processor
    /// of the MPU-60X0 to process accelerometer data, while keeping the gyros off. In this case, the internal relaxation oscillator is
    /// a good clock choice. However, in another mode, where the gyros are active, selecting the gyros as the clock source provides for a more accurate clock source.
    ///
    /// Clock accuracy is important, since timing errors directly affect the distance and angle calculations performed by the
    /// Digital Motion Processor (and by extension, by any processor).
    ///
    /// There are also start-up conditions to consider. When the MPU-60X0 first starts up, the device uses its internal clock until
    /// programmed to operate from another source. This allows the user, for example, to wait for the MEMS oscillators to stabilize before
    /// they are selected as the clock source.
    ///
    /// Note:
    ///
    /// When using SPI interface, user should use `devideReset` (register 107) as well as `SignalPathReset` (register 104) to ensure the
    /// reset is performed properly. The sequence used should be:
    ///
    /// 1. Set `deviceReset` = `true` (register `PowerManagement1`)
    /// 2. Wait 100ms
    /// 3. Set `gyroReset`, `accelReset`, and `tempReset` = `true` (register `SignalPathReset`)
    /// 4. Wait 100ms
    public enum ClockSource: UInt8 {
        /// Internal 8MHz oscillator
        case `internal` = 0

        /// PLL with X axis gyroscope reference
        case xAxisGyro = 1

        /// PLL with Y axis gyroscope reference
        case yAxisGyro = 2

        /// PLL with Z axis gyroscope reference
        case zAxisGyro = 3

        /// PLL with external 32.768kHz reference
        case external32_768kHz = 4

        /// PLL with external 19.2MHz reference
        case external19_2MHz = 5

        /// Stops the clock and keeps the timing generator in reset.
        case stopped = 7
    }

    /// 2-bit unsigned value.
    ///
    /// Specifies the frequency of wake-ups during Accelerometer Only Low Power Mode.
    public var lowPowerWakeup: LowPowerWakeupMode {
        get { register2.getBits(from: 6...7) }
        set { register2.setBits(from: 6...7, to: newValue) }
    }

    /// When set to `true`, this puts the X axis accelerometer into standby mode.
    public var standbyAccelX: Bool {
        get { register2.hasBit(at: 5) }
        set { register2.setBit(at: 5, to: newValue) }
    }

    /// When set to `true`, this puts the Y axis accelerometer into standby mode.
    public var standbyAccelY: Bool {
        get { register2.hasBit(at: 4) }
        set { register2.setBit(at: 4, to: newValue) }
    }

    /// When set to `true`, this puts the Z axis accelerometer into standby mode.
    public var standbyAccelZ: Bool {
        get { register2.hasBit(at: 3) }
        set { register2.setBit(at: 3, to: newValue) }
    }

    /// When set to `true`, this puts the X axis gyroscope into standby mode.
    public var standbyGyroX: Bool {
        get { register2.hasBit(at: 2) }
        set { register2.setBit(at: 2, to: newValue) }
    }

    /// When set to `true`, this puts the Y axis gyroscope into standby mode.
    public var standbyGyroY: Bool {
        get { register2.hasBit(at: 1) }
        set { register2.setBit(at: 1, to: newValue) }
    }

    /// When set to `true`, this puts the Z axis gyroscope into standby mode.
    public var standbyGyroZ: Bool {
        get { register2.hasBit(at: 0) }
        set { register2.setBit(at: 0, to: newValue) }
    }

    /// Determines how the accelerometer will be woken up to take a single measurement while in sleep mode.
    public enum LowPowerWakeupMode: UInt8 {
        case at1_25Hz = 0
        case at5Hz = 1
        case at20Hz = 2
        case at40Hz = 3
    }
}

//------------------------------------------------------------------------------
// Who Am I?
//------------------------------------------------------------------------------

extension MPU6050 {
    public var whoAmI: WhoAmI {
        read(from: 0x75)
    }
}

/// This register is used to verify the identity of the device. The contents of `address6Bits` are the
/// upper 6 bits of the MPU-60X0’s 7-bit I2C address. The least significant bit of the MPU-60X0’s I2C address
/// is determined by the value of the `AD0` pin. The value of the `AD0` pin is not reflected in this register.
///
/// The default value of the register is `0x68`.
///
/// Bits 0 and 7 are reserved. (Hard coded to 0)
public struct WhoAmI: I2CRegisterData {
    public let registerValue: UInt8

    public init(registerValue: UInt8) {
        self.registerValue = registerValue
    }

    /// Contains the 6-bit I2C address of the MPU-60X0.
    ///
    /// The Power-On-Reset value of Bit6:Bit1 is `0b110_100`.
    public var address6Bit: UInt8 { getBits(from: 1...6) }
}
